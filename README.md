# Двоични дървета за търсене

struct Node {
  int key;
  Node* left;
  Node* right;
};


## Да се отговори на въпроса дали елемент го има в дървото
## Да се добави елемент в дървото
## Да се намери най-малкият елемент в дървото
## Да се намери най-големият елемент в дървото
## Да се намери най-близкият общ предшественик на 2 елемента в двоично дърво за търсене. Ако такъв не съществува, да се върне -1.
## А можем ли да представим по друг начин дървото?

## Да се изтрие елемент от дървото
## Да се провери дали дървото е балансирано
## Да се създаде итератор за двойчно дърво за търсене.
## Да се изтрият всички елементи по-големи от X
## По зададени 2 дървета за търсене Т1 и T2 да се генерира ново дърво което съдържа елементите от тяхното сечение. 
   Не се интересуваме каква ще бъде височина, както и подредбата на елементите
## [Не-двоично дърво за търсене] Да се отговори на въпросът дали 2 стойности в дървото са братовчеди.


